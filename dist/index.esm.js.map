{"version":3,"file":"index.esm.js","sources":["../src/utils/polygonUtils.ts","../src/utils/cacheUtils.ts","../src/hooks/usePolygonData.ts","../src/hooks/usePolygonOperations.ts","../src/components/OptimizedPolygon.tsx","../src/components/PolygonMap.tsx"],"sourcesContent":["import * as turf from '@turf/turf';\n\n/**\n * Types for GeoJSON polygon features\n */\nexport interface Polygon {\n    type: 'Polygon';\n    coordinates: number[][][];\n}\n\nexport interface MultiPolygon {\n    type: 'MultiPolygon';\n    coordinates: number[][][][];\n}\n\nexport interface GeoJSONFeature {\n    type: 'Feature';\n    properties?: Record<string, any>;\n    geometry: Polygon | MultiPolygon;\n}\n\nexport interface GeoJSONFeatureCollection {\n    type: 'FeatureCollection';\n    features: GeoJSONFeature[];\n}\n\n/**\n * Flattens a MultiPolygon into a single Polygon\n * @param geojson - The input GeoJSON object\n * @returns A simplified Polygon or the original GeoJSON if not a MultiPolygon\n */\nexport const flattenMultiPolygon = (geojson: any): any => {\n    if (!geojson) return null;\n\n    if (geojson.type === 'MultiPolygon') {\n        return {\n            type: 'Polygon',\n            coordinates: geojson.coordinates.flat(1),\n        };\n    }\n\n    if (geojson.type === 'Feature' && geojson.geometry?.type === 'MultiPolygon') {\n        return {\n            ...geojson,\n            geometry: {\n                type: 'Polygon',\n                coordinates: geojson.geometry.coordinates.flat(1)\n            }\n        };\n    }\n\n    return geojson;\n};\n\n/**\n * Simplifies a polygon to reduce the number of points while maintaining shape\n * @param polygon - The polygon to simplify\n * @param tolerance - The tolerance value (between 0 and 1, higher means more simplification)\n * @returns A simplified polygon\n */\nexport const simplifyPolygon = (polygon: any, tolerance = 0.001): any => {\n    if (!polygon) return null;\n    return turf.simplify(polygon, { tolerance, highQuality: false });\n};\n\n/**\n * Merges multiple polygons into a single polygon\n * @param polygons - Array of polygons to merge\n * @returns A merged polygon\n */\nexport const mergePolygons = (polygons: any[]): any => {\n    if (!polygons || polygons.length === 0) return null;\n    if (polygons.length === 1) return polygons[0];\n\n    try {\n        // Convert to features if they aren't already\n        const features = polygons.map(poly => {\n            if (poly.type === 'Feature') return poly;\n            return turf.feature(poly);\n        });\n\n        // Create a feature collection\n        const featureCollection = turf.featureCollection(features);\n\n        // Perform union\n        // Apply union operations sequentially\n        let result = features[0];\n        for (let i = 1; i < features.length; i++) {\n            result = turf.union(result, features[i]);\n        }\n\n        return result;\n    } catch (error) {\n        console.error('Error merging polygons:', error);\n        return polygons[0]; // Return first polygon as fallback\n    }\n};\n\n/**\n * Calculates area of a polygon in square meters\n * @param polygon - The polygon to calculate area for\n * @returns Area in square meters\n */\nexport const calculateArea = (polygon: any): number => {\n    if (!polygon) return 0;\n    return turf.area(polygon);\n};\n\n/**\n * Checks if a point is inside a polygon\n * @param point - [longitude, latitude] coordinates\n * @param polygon - The polygon to check against\n * @returns Boolean indicating if point is inside polygon\n */\nexport const isPointInPolygon = (point: [number, number], polygon: any): boolean => {\n    if (!point || !polygon) return false;\n\n    const pt = turf.point(point);\n    return turf.booleanPointInPolygon(pt, polygon);\n};\n\n/**\n * Optimizes a GeoJSON object for frontend rendering\n * @param geojson - The GeoJSON object to optimize\n * @param options - Optimization options\n * @returns Optimized GeoJSON\n */\nexport const optimizeForRendering = (\n    geojson: any,\n    options: {\n        simplify?: boolean;\n        simplifyTolerance?: number;\n        flatten?: boolean;\n    } = {}\n): any => {\n    if (!geojson) return null;\n\n    const {\n        simplify = true,\n        simplifyTolerance = 0.001,\n        flatten = true\n    } = options;\n\n    let result = geojson;\n\n    // Flatten multi-polygons if needed\n    if (flatten) {\n        result = flattenMultiPolygon(result);\n    }\n\n    // Simplify if needed\n    if (simplify) {\n        result = simplifyPolygon(result, simplifyTolerance);\n    }\n\n    return result;\n}; ","/**\n * A simple LRU (Least Recently Used) cache implementation\n */\nexport class LRUCache<K, V> {\n    private capacity: number;\n    private cache: Map<K, V>;\n\n    /**\n     * Creates a new LRU cache with the specified capacity\n     * @param capacity - Maximum number of items to store\n     */\n    constructor(capacity: number = 100) {\n        this.capacity = capacity;\n        this.cache = new Map<K, V>();\n    }\n\n    /**\n     * Gets a value from the cache\n     * @param key - The key to look up\n     * @returns The cached value or undefined if not found\n     */\n    get(key: K): V | undefined {\n        if (!this.cache.has(key)) {\n            return undefined;\n        }\n\n        // Get the value\n        const value = this.cache.get(key)!;\n\n        // Remove and re-add to put it at the end (most recently used)\n        this.cache.delete(key);\n        this.cache.set(key, value);\n\n        return value;\n    }\n\n    /**\n     * Sets a value in the cache\n     * @param key - The key to store\n     * @param value - The value to cache\n     */\n    set(key: K, value: V): void {\n        // If already exists, remove it to update order\n        if (this.cache.has(key)) {\n            this.cache.delete(key);\n        }\n        // If at capacity, remove the oldest item (first item in Map)\n        else if (this.cache.size >= this.capacity) {\n            const oldestKey = this.cache.keys().next().value;\n            // Check if we have a valid key\n            if (oldestKey !== undefined) {\n                this.cache.delete(oldestKey);\n            }\n        }\n\n        // Add new item\n        this.cache.set(key, value);\n    }\n\n    /**\n     * Removes a value from the cache\n     * @param key - The key to remove\n     * @returns Whether the key was present in the cache\n     */\n    delete(key: K): boolean {\n        return this.cache.delete(key);\n    }\n\n    /**\n     * Clears the entire cache\n     */\n    clear(): void {\n        this.cache.clear();\n    }\n\n    /**\n     * Gets the current size of the cache\n     * @returns Number of items in the cache\n     */\n    size(): number {\n        return this.cache.size;\n    }\n\n    /**\n     * Gets all keys in the cache\n     * @returns Array of all keys\n     */\n    keys(): K[] {\n        return Array.from(this.cache.keys());\n    }\n}\n\n/**\n * Creates a memoized version of a function that caches results\n * \n * @param fn - The function to memoize\n * @param getKey - Optional function to generate a custom cache key\n * @param options - Cache options including capacity\n * @returns A memoized version of the function\n */\nexport function memoize<T extends (...args: any[]) => any>(\n    fn: T,\n    getKey: (...args: Parameters<T>) => string = (...args) => JSON.stringify(args),\n    options: { capacity?: number } = {}\n): T {\n    const cache = new LRUCache<string, ReturnType<T>>(options.capacity || 100);\n\n    return ((...args: Parameters<T>): ReturnType<T> => {\n        const key = getKey(...args);\n        const cachedResult = cache.get(key);\n\n        // If we have a cached result, return it\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n\n        // Calculate the result\n        const result = fn(...args);\n\n        // Cache the result\n        cache.set(key, result);\n\n        return result;\n    }) as T;\n} ","import { useState, useEffect, useCallback, useRef } from 'react';\nimport { optimizeForRendering } from '../utils/polygonUtils';\nimport { memoize } from '../utils/cacheUtils';\n\nexport interface UsePolygonDataOptions {\n    /**\n     * Whether to flatten MultiPolygons into Polygons\n     */\n    flatten?: boolean;\n\n    /**\n     * Whether to simplify polygons\n     */\n    simplify?: boolean;\n\n    /**\n     * Tolerance level for simplification (0-1)\n     */\n    simplifyTolerance?: number;\n\n    /**\n     * Polling interval in milliseconds (0 to disable polling)\n     */\n    pollingInterval?: number;\n\n    /**\n     * Whether to auto-optimize polygons for rendering\n     */\n    autoOptimize?: boolean;\n}\n\nexport interface UsePolygonDataResult<T> {\n    /**\n     * The processed polygon data\n     */\n    data: T | null;\n\n    /**\n     * Whether data is currently being loaded\n     */\n    loading: boolean;\n\n    /**\n     * Any error that occurred during loading\n     */\n    error: Error | null;\n\n    /**\n     * Manually refresh the data\n     */\n    refresh: () => Promise<void>;\n}\n\n/**\n * Hook for fetching and processing polygon data\n * \n * @param url - URL to fetch polygon data from\n * @param options - Configuration options\n * @returns Object containing data, loading state, error state, and a refresh function\n */\nexport function usePolygonData<T = any>(\n    url: string,\n    options: UsePolygonDataOptions = {}\n): UsePolygonDataResult<T> {\n    const {\n        flatten = true,\n        simplify = true,\n        simplifyTolerance = 0.001,\n        pollingInterval = 0,\n        autoOptimize = true,\n    } = options;\n\n    const [data, setData] = useState<T | null>(null);\n    const [loading, setLoading] = useState<boolean>(true);\n    const [error, setError] = useState<Error | null>(null);\n\n    // Create a memoized version of optimizeForRendering to avoid reprocessing the same data\n    const memoizedOptimize = useRef(\n        memoize(\n            (data: any) => optimizeForRendering(data, {\n                simplify,\n                simplifyTolerance,\n                flatten\n            }),\n            (data) => JSON.stringify({\n                id: data.id || Math.random().toString(36).substring(2, 9),\n                lastModified: data.lastModified || Date.now()\n            }),\n            { capacity: 20 }\n        )\n    ).current;\n\n    const fetchData = useCallback(async () => {\n        try {\n            setLoading(true);\n            setError(null);\n\n            const response = await fetch(url);\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n\n            const jsonData = await response.json();\n\n            // Process the data if auto-optimize is enabled\n            const processedData = autoOptimize ? memoizedOptimize(jsonData) : jsonData;\n\n            setData(processedData as T);\n            setLoading(false);\n        } catch (err) {\n            setError(err instanceof Error ? err : new Error(String(err)));\n            setLoading(false);\n        }\n    }, [url, autoOptimize, memoizedOptimize]);\n\n    // Set up polling if enabled\n    useEffect(() => {\n        // Initial fetch\n        fetchData();\n\n        // Set up polling if interval > 0\n        let intervalId: ReturnType<typeof setInterval> | undefined;\n\n        if (pollingInterval > 0) {\n            intervalId = setInterval(fetchData, pollingInterval);\n        }\n\n        // Cleanup\n        return () => {\n            if (intervalId) {\n                clearInterval(intervalId);\n            }\n        };\n    }, [fetchData, pollingInterval]);\n\n    const refresh = useCallback(async () => {\n        await fetchData();\n    }, [fetchData]);\n\n    return { data, loading, error, refresh };\n} ","import { useMemo, useCallback } from 'react';\nimport {\n    simplifyPolygon,\n    flattenMultiPolygon,\n    mergePolygons,\n    calculateArea,\n    isPointInPolygon\n} from '../utils/polygonUtils';\nimport { memoize } from '../utils/cacheUtils';\n\nexport interface PolygonOperationsOptions {\n    /**\n     * Default tolerance level for simplification (0-1)\n     */\n    defaultSimplifyTolerance?: number;\n\n    /**\n     * Whether to use memoization for expensive operations\n     */\n    useMemoization?: boolean;\n\n    /**\n     * Cache size for memoized functions\n     */\n    cacheSize?: number;\n}\n\n/**\n * Hook that provides optimized polygon manipulation functions\n * \n * @param options - Configuration options\n * @returns Object containing various polygon utility functions\n */\nexport function usePolygonOperations(\n    options: PolygonOperationsOptions = {}\n) {\n    const {\n        defaultSimplifyTolerance = 0.001,\n        useMemoization = true,\n        cacheSize = 50\n    } = options;\n\n    // Create memoized versions of functions if memoization is enabled\n    const memoizedSimplify = useMemo(() => {\n        return useMemoization\n            ? memoize(simplifyPolygon, (polygon, tolerance) =>\n                `${JSON.stringify(polygon)}-${tolerance}`, { capacity: cacheSize })\n            : simplifyPolygon;\n    }, [useMemoization, cacheSize]);\n\n    const memoizedFlatten = useMemo(() => {\n        return useMemoization\n            ? memoize(flattenMultiPolygon, geojson =>\n                JSON.stringify(geojson), { capacity: cacheSize })\n            : flattenMultiPolygon;\n    }, [useMemoization, cacheSize]);\n\n    const memoizedMerge = useMemo(() => {\n        return useMemoization\n            ? memoize(mergePolygons, polygons =>\n                JSON.stringify(polygons.map(p => p.id || JSON.stringify(p))), { capacity: cacheSize })\n            : mergePolygons;\n    }, [useMemoization, cacheSize]);\n\n    const memoizedCalculateArea = useMemo(() => {\n        return useMemoization\n            ? memoize(calculateArea, polygon =>\n                JSON.stringify(polygon), { capacity: cacheSize })\n            : calculateArea;\n    }, [useMemoization, cacheSize]);\n\n    const memoizedIsPointInPolygon = useMemo(() => {\n        return useMemoization\n            ? memoize(isPointInPolygon, (point, polygon) =>\n                `${point.join(',')}-${JSON.stringify(polygon)}`, { capacity: cacheSize })\n            : isPointInPolygon;\n    }, [useMemoization, cacheSize]);\n\n    // Function to simplify a polygon with the default tolerance\n    const simplify = useCallback((polygon: any, tolerance?: number) => {\n        return memoizedSimplify(polygon, tolerance || defaultSimplifyTolerance);\n    }, [memoizedSimplify, defaultSimplifyTolerance]);\n\n    // Function to flatten a multi-polygon\n    const flatten = useCallback((polygon: any) => {\n        return memoizedFlatten(polygon);\n    }, [memoizedFlatten]);\n\n    // Function to merge multiple polygons\n    const merge = useCallback((polygons: any[]) => {\n        return memoizedMerge(polygons);\n    }, [memoizedMerge]);\n\n    // Function to calculate area\n    const area = useCallback((polygon: any) => {\n        return memoizedCalculateArea(polygon);\n    }, [memoizedCalculateArea]);\n\n    // Function to check if a point is inside a polygon\n    const contains = useCallback((point: [number, number], polygon: any) => {\n        return memoizedIsPointInPolygon(point, polygon);\n    }, [memoizedIsPointInPolygon]);\n\n    return {\n        simplify,\n        flatten,\n        merge,\n        area,\n        contains\n    };\n} ","import React, { useMemo } from 'react';\nimport { optimizeForRendering } from '../utils/polygonUtils';\nimport { memoize } from '../utils/cacheUtils';\n\nexport interface OptimizedPolygonProps {\n    /**\n     * The polygon data to render\n     */\n    data: any;\n\n    /**\n     * Whether to automatically optimize the polygon for rendering\n     */\n    autoOptimize?: boolean;\n\n    /**\n     * Whether to simplify the polygon\n     */\n    simplify?: boolean;\n\n    /**\n     * Tolerance level for simplification (0-1)\n     */\n    simplifyTolerance?: number;\n\n    /**\n     * Whether to flatten multi-polygons\n     */\n    flatten?: boolean;\n\n    /**\n     * Render function that receives the optimized polygon data\n     */\n    children: (optimizedData: any) => React.ReactNode;\n\n    /**\n     * Unique ID for the polygon (used for optimization)\n     */\n    id?: string;\n}\n\n// Create a memoized version of optimizeForRendering function\nconst memoizedOptimize = memoize(\n    (data: any, options: any) => optimizeForRendering(data, options),\n    (data, options) => JSON.stringify({\n        id: data.id || data.properties?.id,\n        options\n    }),\n    { capacity: 50 }\n);\n\n/**\n * Component that optimizes polygon data before rendering\n */\nexport const OptimizedPolygon: React.FC<OptimizedPolygonProps> = ({\n    data,\n    autoOptimize = true,\n    simplify = true,\n    simplifyTolerance = 0.001,\n    flatten = true,\n    children,\n    id\n}) => {\n    // Only optimize if autoOptimize is true\n    const optimizedData = useMemo(() => {\n        if (!data) return null;\n\n        // If we shouldn't auto-optimize, just return the data as-is\n        if (!autoOptimize) return data;\n\n        // Create a configuration object\n        const options = {\n            simplify,\n            simplifyTolerance,\n            flatten\n        };\n\n        // Add ID to data if provided\n        const dataWithId = id && !data.id ? { ...data, id } : data;\n\n        // Use memoized optimization\n        return memoizedOptimize(dataWithId, options);\n    }, [data, autoOptimize, simplify, simplifyTolerance, flatten, id]);\n\n    // Render nothing if there's no data\n    if (!optimizedData) {\n        return null;\n    }\n\n    // Use render prop pattern to render the optimized data\n    return <>{children(optimizedData)}</>;\n}; ","import React, { useCallback, memo } from 'react';\nimport { OptimizedPolygon } from './OptimizedPolygon';\nimport { usePolygonOperations } from '../hooks/usePolygonOperations';\n\nexport interface PolygonMapProps {\n    /**\n     * Array of polygon data to render\n     */\n    polygons: any[];\n\n    /**\n     * Render prop for rendering each individual polygon\n     */\n    renderPolygon: (polygon: any, index: number) => React.ReactNode;\n\n    /**\n     * Whether to automatically optimize polygons\n     */\n    autoOptimize?: boolean;\n\n    /**\n     * Whether to simplify polygons\n     */\n    simplify?: boolean;\n\n    /**\n     * Tolerance level for simplification (0-1)\n     */\n    simplifyTolerance?: number;\n\n    /**\n     * Whether to flatten multi-polygons\n     */\n    flatten?: boolean;\n\n    /**\n     * Function to get a unique ID for each polygon\n     */\n    getPolygonId?: (polygon: any, index: number) => string;\n\n    /**\n     * Optional className for the container\n     */\n    className?: string;\n\n    /**\n     * Optional style for the container\n     */\n    style?: React.CSSProperties;\n}\n\n/**\n * A component for efficiently rendering multiple polygons on a map\n */\nexport const PolygonMap: React.FC<PolygonMapProps> = memo(({\n    polygons = [],\n    renderPolygon,\n    autoOptimize = true,\n    simplify = true,\n    simplifyTolerance = 0.001,\n    flatten = true,\n    getPolygonId = (p: any, i: number) => p.id || p.properties?.id || `polygon-${i}`,\n    className,\n    style\n}) => {\n    // Get polygon operations\n    const operations = usePolygonOperations({\n        defaultSimplifyTolerance: simplifyTolerance\n    });\n\n    // Function to optimize a single polygon\n    const optimizePolygon = useCallback((polygon: any) => {\n        if (!autoOptimize) return polygon;\n\n        let result = polygon;\n\n        if (flatten) {\n            result = operations.flatten(result);\n        }\n\n        if (simplify) {\n            result = operations.simplify(result, simplifyTolerance);\n        }\n\n        return result;\n    }, [autoOptimize, flatten, simplify, simplifyTolerance, operations]);\n\n    // If no polygons, render an empty div\n    if (!polygons || polygons.length === 0) {\n        return <div className={className} style={style}></div>;\n    }\n\n    return (\n        <div className={className} style={style}>\n            {polygons.map((polygon, index) => {\n                // Get unique ID for this polygon\n                const id = getPolygonId(polygon, index);\n\n                return (\n                    <OptimizedPolygon\n                        key={id}\n                        id={id}\n                        data={polygon}\n                        autoOptimize={autoOptimize}\n                        simplify={simplify}\n                        simplifyTolerance={simplifyTolerance}\n                        flatten={flatten}\n                    >\n                        {(optimizedPolygon) => renderPolygon(optimizedPolygon, index)}\n                    </OptimizedPolygon>\n                );\n            })}\n        </div>\n    );\n}); "],"names":["flattenMultiPolygon","geojson","type","coordinates","flat","_a","geometry","__assign","simplifyPolygon","polygon","tolerance","turf","simplify","highQuality","mergePolygons","polygons","length","features","map","poly","feature","result","featureCollection","i","union","error","console","calculateArea","area","isPointInPolygon","point","pt","booleanPointInPolygon","optimizeForRendering","options","_b","simplifyTolerance","_c","flatten","LRUCache","capacity","this","cache","Map","prototype","get","key","has","value","delete","set","size","oldestKey","keys","next","undefined","clear","Array","from","memoize","fn","getKey","args","_i","arguments","JSON","stringify","apply","cachedResult","usePolygonData","url","_this","_d","pollingInterval","_e","autoOptimize","_f","useState","data","setData","_g","loading","setLoading","_h","setError","memoizedOptimize","useRef","id","Math","random","toString","substring","lastModified","Date","now","current","fetchData","useCallback","__awaiter","fetch","response","sent","ok","Error","concat","status","json","jsonData","processedData","err_1","String","useEffect","intervalId","setInterval","clearInterval","refresh","usePolygonOperations","defaultSimplifyTolerance","useMemoization","cacheSize","memoizedSimplify","useMemo","memoizedFlatten","memoizedMerge","p","memoizedCalculateArea","memoizedIsPointInPolygon","join","merge","contains","properties","OptimizedPolygon","children","optimizedData","dataWithId","React","PolygonMap","memo","renderPolygon","getPolygonId","className","style","operations","createElement","index","optimizedPolygon"],"mappings":"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"}