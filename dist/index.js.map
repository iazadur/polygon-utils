{"version":3,"file":"index.js","sources":["../src/utils/polygonUtils.ts","../src/utils/cacheUtils.ts","../src/hooks/usePolygonOperations.ts","../src/components/OptimizedPolygon.tsx","../src/components/PolygonMap.tsx","../src/hooks/usePolygonData.ts"],"sourcesContent":["import * as turf from '@turf/turf';\n\n/**\n * Types for GeoJSON polygon features\n */\nexport interface Polygon {\n    type: 'Polygon';\n    coordinates: number[][][];\n}\n\nexport interface MultiPolygon {\n    type: 'MultiPolygon';\n    coordinates: number[][][][];\n}\n\nexport interface GeoJSONFeature {\n    type: 'Feature';\n    properties?: Record<string, any>;\n    geometry: Polygon | MultiPolygon;\n}\n\nexport interface GeoJSONFeatureCollection {\n    type: 'FeatureCollection';\n    features: GeoJSONFeature[];\n}\n\n/**\n * Flattens a MultiPolygon into a single Polygon\n * @param geojson - The input GeoJSON object\n * @returns A simplified Polygon or the original GeoJSON if not a MultiPolygon\n */\nexport const flattenMultiPolygon = (geojson: any): any => {\n    if (!geojson) return null;\n\n    if (geojson.type === 'MultiPolygon') {\n        return {\n            type: 'Polygon',\n            coordinates: geojson.coordinates.flat(1),\n        };\n    }\n\n    if (geojson.type === 'Feature' && geojson.geometry?.type === 'MultiPolygon') {\n        return {\n            ...geojson,\n            geometry: {\n                type: 'Polygon',\n                coordinates: geojson.geometry.coordinates.flat(1)\n            }\n        };\n    }\n\n    return geojson;\n};\n\n/**\n * Simplifies a polygon to reduce the number of points while maintaining shape\n * @param polygon - The polygon to simplify\n * @param tolerance - The tolerance value (between 0 and 1, higher means more simplification)\n * @returns A simplified polygon\n */\nexport const simplifyPolygon = (polygon: any, tolerance = 0.001): any => {\n    if (!polygon) return null;\n    return turf.simplify(polygon, { tolerance, highQuality: false });\n};\n\n/**\n * Merges multiple polygons into a single polygon\n * @param polygons - Array of polygons to merge\n * @returns A merged polygon\n */\nexport const mergePolygons = (polygons: any[]): any => {\n    if (!polygons || polygons.length === 0) return null;\n    if (polygons.length === 1) return polygons[0];\n\n    try {\n        // Convert to features if they aren't already\n        const features = polygons.map(poly => {\n            if (poly.type === 'Feature') return poly;\n            return turf.feature(poly);\n        });\n\n        // Create a feature collection\n        const featureCollection = turf.featureCollection(features);\n\n        // Perform union\n        // Apply union operations sequentially\n        let result = features[0];\n        for (let i = 1; i < features.length; i++) {\n            result = turf.union(result, features[i]);\n        }\n\n        return result;\n    } catch (error) {\n        console.error('Error merging polygons:', error);\n        return polygons[0]; // Return first polygon as fallback\n    }\n};\n\n/**\n * Calculates area of a polygon in square meters\n * @param polygon - The polygon to calculate area for\n * @returns Area in square meters\n */\nexport const calculateArea = (polygon: any): number => {\n    if (!polygon) return 0;\n    return turf.area(polygon);\n};\n\n/**\n * Checks if a point is inside a polygon\n * @param point - [longitude, latitude] coordinates\n * @param polygon - The polygon to check against\n * @returns Boolean indicating if point is inside polygon\n */\nexport const isPointInPolygon = (point: [number, number], polygon: any): boolean => {\n    if (!point || !polygon) return false;\n\n    const pt = turf.point(point);\n    return turf.booleanPointInPolygon(pt, polygon);\n};\n\n/**\n * Optimizes a GeoJSON object for frontend rendering\n * @param geojson - The GeoJSON object to optimize\n * @param options - Optimization options\n * @returns Optimized GeoJSON\n */\nexport const optimizeForRendering = (\n    geojson: any,\n    options: {\n        simplify?: boolean;\n        simplifyTolerance?: number;\n        flatten?: boolean;\n    } = {}\n): any => {\n    if (!geojson) return null;\n\n    const {\n        simplify = true,\n        simplifyTolerance = 0.001,\n        flatten = true\n    } = options;\n\n    let result = geojson;\n\n    // Flatten multi-polygons if needed\n    if (flatten) {\n        result = flattenMultiPolygon(result);\n    }\n\n    // Simplify if needed\n    if (simplify) {\n        result = simplifyPolygon(result, simplifyTolerance);\n    }\n\n    return result;\n}; ","/**\n * A simple LRU (Least Recently Used) cache implementation\n */\nexport class LRUCache<K, V> {\n    private capacity: number;\n    private cache: Map<K, V>;\n\n    /**\n     * Creates a new LRU cache with the specified capacity\n     * @param capacity - Maximum number of items to store\n     */\n    constructor(capacity: number = 100) {\n        this.capacity = capacity;\n        this.cache = new Map<K, V>();\n    }\n\n    /**\n     * Gets a value from the cache\n     * @param key - The key to look up\n     * @returns The cached value or undefined if not found\n     */\n    get(key: K): V | undefined {\n        if (!this.cache.has(key)) {\n            return undefined;\n        }\n\n        // Get the value\n        const value = this.cache.get(key)!;\n\n        // Remove and re-add to put it at the end (most recently used)\n        this.cache.delete(key);\n        this.cache.set(key, value);\n\n        return value;\n    }\n\n    /**\n     * Sets a value in the cache\n     * @param key - The key to store\n     * @param value - The value to cache\n     */\n    set(key: K, value: V): void {\n        // If already exists, remove it to update order\n        if (this.cache.has(key)) {\n            this.cache.delete(key);\n        }\n        // If at capacity, remove the oldest item (first item in Map)\n        else if (this.cache.size >= this.capacity) {\n            const oldestKey = this.cache.keys().next().value;\n            // Check if we have a valid key\n            if (oldestKey !== undefined) {\n                this.cache.delete(oldestKey);\n            }\n        }\n\n        // Add new item\n        this.cache.set(key, value);\n    }\n\n    /**\n     * Removes a value from the cache\n     * @param key - The key to remove\n     * @returns Whether the key was present in the cache\n     */\n    delete(key: K): boolean {\n        return this.cache.delete(key);\n    }\n\n    /**\n     * Clears the entire cache\n     */\n    clear(): void {\n        this.cache.clear();\n    }\n\n    /**\n     * Gets the current size of the cache\n     * @returns Number of items in the cache\n     */\n    size(): number {\n        return this.cache.size;\n    }\n\n    /**\n     * Gets all keys in the cache\n     * @returns Array of all keys\n     */\n    keys(): K[] {\n        return Array.from(this.cache.keys());\n    }\n}\n\n/**\n * Creates a memoized version of a function that caches results\n * \n * @param fn - The function to memoize\n * @param getKey - Optional function to generate a custom cache key\n * @param options - Cache options including capacity\n * @returns A memoized version of the function\n */\nexport function memoize<T extends (...args: any[]) => any>(\n    fn: T,\n    getKey: (...args: Parameters<T>) => string = (...args) => JSON.stringify(args),\n    options: { capacity?: number } = {}\n): T {\n    const cache = new LRUCache<string, ReturnType<T>>(options.capacity || 100);\n\n    return ((...args: Parameters<T>): ReturnType<T> => {\n        const key = getKey(...args);\n        const cachedResult = cache.get(key);\n\n        // If we have a cached result, return it\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n\n        // Calculate the result\n        const result = fn(...args);\n\n        // Cache the result\n        cache.set(key, result);\n\n        return result;\n    }) as T;\n} ","import { useMemo, useCallback } from 'react';\nimport {\n    simplifyPolygon,\n    flattenMultiPolygon,\n    mergePolygons,\n    calculateArea,\n    isPointInPolygon\n} from '../utils/polygonUtils';\nimport { memoize } from '../utils/cacheUtils';\n\nexport interface PolygonOperationsOptions {\n    /**\n     * Default tolerance level for simplification (0-1)\n     */\n    defaultSimplifyTolerance?: number;\n\n    /**\n     * Whether to use memoization for expensive operations\n     */\n    useMemoization?: boolean;\n\n    /**\n     * Cache size for memoized functions\n     */\n    cacheSize?: number;\n}\n\n/**\n * Hook that provides optimized polygon manipulation functions\n * \n * @param options - Configuration options\n * @returns Object containing various polygon utility functions\n */\nexport function usePolygonOperations(\n    options: PolygonOperationsOptions = {}\n) {\n    const {\n        defaultSimplifyTolerance = 0.001,\n        useMemoization = true,\n        cacheSize = 50\n    } = options;\n\n    // Create memoized versions of functions if memoization is enabled\n    const memoizedSimplify = useMemo(() => {\n        return useMemoization\n            ? memoize(simplifyPolygon, (polygon, tolerance) =>\n                `${JSON.stringify(polygon)}-${tolerance}`, { capacity: cacheSize })\n            : simplifyPolygon;\n    }, [useMemoization, cacheSize]);\n\n    const memoizedFlatten = useMemo(() => {\n        return useMemoization\n            ? memoize(flattenMultiPolygon, geojson =>\n                JSON.stringify(geojson), { capacity: cacheSize })\n            : flattenMultiPolygon;\n    }, [useMemoization, cacheSize]);\n\n    const memoizedMerge = useMemo(() => {\n        return useMemoization\n            ? memoize(mergePolygons, polygons =>\n                JSON.stringify(polygons.map(p => p.id || JSON.stringify(p))), { capacity: cacheSize })\n            : mergePolygons;\n    }, [useMemoization, cacheSize]);\n\n    const memoizedCalculateArea = useMemo(() => {\n        return useMemoization\n            ? memoize(calculateArea, polygon =>\n                JSON.stringify(polygon), { capacity: cacheSize })\n            : calculateArea;\n    }, [useMemoization, cacheSize]);\n\n    const memoizedIsPointInPolygon = useMemo(() => {\n        return useMemoization\n            ? memoize(isPointInPolygon, (point, polygon) =>\n                `${point.join(',')}-${JSON.stringify(polygon)}`, { capacity: cacheSize })\n            : isPointInPolygon;\n    }, [useMemoization, cacheSize]);\n\n    // Function to simplify a polygon with the default tolerance\n    const simplify = useCallback((polygon: any, tolerance?: number) => {\n        return memoizedSimplify(polygon, tolerance || defaultSimplifyTolerance);\n    }, [memoizedSimplify, defaultSimplifyTolerance]);\n\n    // Function to flatten a multi-polygon\n    const flatten = useCallback((polygon: any) => {\n        return memoizedFlatten(polygon);\n    }, [memoizedFlatten]);\n\n    // Function to merge multiple polygons\n    const merge = useCallback((polygons: any[]) => {\n        return memoizedMerge(polygons);\n    }, [memoizedMerge]);\n\n    // Function to calculate area\n    const area = useCallback((polygon: any) => {\n        return memoizedCalculateArea(polygon);\n    }, [memoizedCalculateArea]);\n\n    // Function to check if a point is inside a polygon\n    const contains = useCallback((point: [number, number], polygon: any) => {\n        return memoizedIsPointInPolygon(point, polygon);\n    }, [memoizedIsPointInPolygon]);\n\n    return {\n        simplify,\n        flatten,\n        merge,\n        area,\n        contains\n    };\n} ","import React, { useMemo } from 'react';\nimport { optimizeForRendering } from '../utils/polygonUtils';\nimport { memoize } from '../utils/cacheUtils';\n\nexport interface OptimizedPolygonProps {\n    /**\n     * The polygon data to render\n     */\n    data: any;\n\n    /**\n     * Whether to automatically optimize the polygon for rendering\n     */\n    autoOptimize?: boolean;\n\n    /**\n     * Whether to simplify the polygon\n     */\n    simplify?: boolean;\n\n    /**\n     * Tolerance level for simplification (0-1)\n     */\n    simplifyTolerance?: number;\n\n    /**\n     * Whether to flatten multi-polygons\n     */\n    flatten?: boolean;\n\n    /**\n     * Render function that receives the optimized polygon data\n     */\n    children: (optimizedData: any) => React.ReactNode;\n\n    /**\n     * Unique ID for the polygon (used for optimization)\n     */\n    id?: string;\n}\n\n// Create a memoized version of optimizeForRendering function\nconst memoizedOptimize = memoize(\n    (data: any, options: any) => optimizeForRendering(data, options),\n    (data, options) => JSON.stringify({\n        id: data.id || data.properties?.id,\n        options\n    }),\n    { capacity: 50 }\n);\n\n/**\n * Component that optimizes polygon data before rendering\n */\nexport const OptimizedPolygon: React.FC<OptimizedPolygonProps> = ({\n    data,\n    autoOptimize = true,\n    simplify = true,\n    simplifyTolerance = 0.001,\n    flatten = true,\n    children,\n    id\n}) => {\n    // Only optimize if autoOptimize is true\n    const optimizedData = useMemo(() => {\n        if (!data) return null;\n\n        // If we shouldn't auto-optimize, just return the data as-is\n        if (!autoOptimize) return data;\n\n        // Create a configuration object\n        const options = {\n            simplify,\n            simplifyTolerance,\n            flatten\n        };\n\n        // Add ID to data if provided\n        const dataWithId = id && !data.id ? { ...data, id } : data;\n\n        // Use memoized optimization\n        return memoizedOptimize(dataWithId, options);\n    }, [data, autoOptimize, simplify, simplifyTolerance, flatten, id]);\n\n    // Render nothing if there's no data\n    if (!optimizedData) {\n        return null;\n    }\n\n    // Use render prop pattern to render the optimized data\n    return <>{children(optimizedData)}</>;\n}; ","import React, { useCallback, memo } from 'react';\nimport { OptimizedPolygon } from './OptimizedPolygon';\nimport { usePolygonOperations } from '../hooks/usePolygonOperations';\n\nexport interface PolygonMapProps {\n    /**\n     * Array of polygon data to render\n     */\n    polygons: any[];\n\n    /**\n     * Render prop for rendering each individual polygon\n     */\n    renderPolygon: (polygon: any, index: number) => React.ReactNode;\n\n    /**\n     * Whether to automatically optimize polygons\n     */\n    autoOptimize?: boolean;\n\n    /**\n     * Whether to simplify polygons\n     */\n    simplify?: boolean;\n\n    /**\n     * Tolerance level for simplification (0-1)\n     */\n    simplifyTolerance?: number;\n\n    /**\n     * Whether to flatten multi-polygons\n     */\n    flatten?: boolean;\n\n    /**\n     * Function to get a unique ID for each polygon\n     */\n    getPolygonId?: (polygon: any, index: number) => string;\n\n    /**\n     * Optional className for the container\n     */\n    className?: string;\n\n    /**\n     * Optional style for the container\n     */\n    style?: React.CSSProperties;\n}\n\n/**\n * A component for efficiently rendering multiple polygons on a map\n */\nexport const PolygonMap: React.FC<PolygonMapProps> = memo(({\n    polygons = [],\n    renderPolygon,\n    autoOptimize = true,\n    simplify = true,\n    simplifyTolerance = 0.001,\n    flatten = true,\n    getPolygonId = (p: any, i: number) => p.id || p.properties?.id || `polygon-${i}`,\n    className,\n    style\n}) => {\n    // Get polygon operations\n    const operations = usePolygonOperations({\n        defaultSimplifyTolerance: simplifyTolerance\n    });\n\n    // Function to optimize a single polygon\n    const optimizePolygon = useCallback((polygon: any) => {\n        if (!autoOptimize) return polygon;\n\n        let result = polygon;\n\n        if (flatten) {\n            result = operations.flatten(result);\n        }\n\n        if (simplify) {\n            result = operations.simplify(result, simplifyTolerance);\n        }\n\n        return result;\n    }, [autoOptimize, flatten, simplify, simplifyTolerance, operations]);\n\n    // If no polygons, render an empty div\n    if (!polygons || polygons.length === 0) {\n        return <div className={className} style={style}></div>;\n    }\n\n    return (\n        <div className={className} style={style}>\n            {polygons.map((polygon, index) => {\n                // Get unique ID for this polygon\n                const id = getPolygonId(polygon, index);\n\n                return (\n                    <OptimizedPolygon\n                        key={id}\n                        id={id}\n                        data={polygon}\n                        autoOptimize={autoOptimize}\n                        simplify={simplify}\n                        simplifyTolerance={simplifyTolerance}\n                        flatten={flatten}\n                    >\n                        {(optimizedPolygon) => renderPolygon(optimizedPolygon, index)}\n                    </OptimizedPolygon>\n                );\n            })}\n        </div>\n    );\n}); ","import { useState, useEffect, useCallback, useRef } from 'react';\nimport { optimizeForRendering } from '../utils/polygonUtils';\nimport { memoize } from '../utils/cacheUtils';\n\nexport interface UsePolygonDataOptions {\n    /**\n     * Whether to flatten MultiPolygons into Polygons\n     */\n    flatten?: boolean;\n\n    /**\n     * Whether to simplify polygons\n     */\n    simplify?: boolean;\n\n    /**\n     * Tolerance level for simplification (0-1)\n     */\n    simplifyTolerance?: number;\n\n    /**\n     * Polling interval in milliseconds (0 to disable polling)\n     */\n    pollingInterval?: number;\n\n    /**\n     * Whether to auto-optimize polygons for rendering\n     */\n    autoOptimize?: boolean;\n}\n\nexport interface UsePolygonDataResult<T> {\n    /**\n     * The processed polygon data\n     */\n    data: T | null;\n\n    /**\n     * Whether data is currently being loaded\n     */\n    loading: boolean;\n\n    /**\n     * Any error that occurred during loading\n     */\n    error: Error | null;\n\n    /**\n     * Manually refresh the data\n     */\n    refresh: () => Promise<void>;\n}\n\n/**\n * Hook for fetching and processing polygon data\n * \n * @param url - URL to fetch polygon data from\n * @param options - Configuration options\n * @returns Object containing data, loading state, error state, and a refresh function\n */\nexport function usePolygonData<T = any>(\n    url: string,\n    options: UsePolygonDataOptions = {}\n): UsePolygonDataResult<T> {\n    const {\n        flatten = true,\n        simplify = true,\n        simplifyTolerance = 0.001,\n        pollingInterval = 0,\n        autoOptimize = true,\n    } = options;\n\n    const [data, setData] = useState<T | null>(null);\n    const [loading, setLoading] = useState<boolean>(true);\n    const [error, setError] = useState<Error | null>(null);\n\n    // Create a memoized version of optimizeForRendering to avoid reprocessing the same data\n    const memoizedOptimize = useRef(\n        memoize(\n            (data: any) => optimizeForRendering(data, {\n                simplify,\n                simplifyTolerance,\n                flatten\n            }),\n            (data) => JSON.stringify({\n                id: data.id || Math.random().toString(36).substring(2, 9),\n                lastModified: data.lastModified || Date.now()\n            }),\n            { capacity: 20 }\n        )\n    ).current;\n\n    const fetchData = useCallback(async () => {\n        try {\n            setLoading(true);\n            setError(null);\n\n            const response = await fetch(url);\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n\n            const jsonData = await response.json();\n\n            // Process the data if auto-optimize is enabled\n            const processedData = autoOptimize ? memoizedOptimize(jsonData) : jsonData;\n\n            setData(processedData as T);\n            setLoading(false);\n        } catch (err) {\n            setError(err instanceof Error ? err : new Error(String(err)));\n            setLoading(false);\n        }\n    }, [url, autoOptimize, memoizedOptimize]);\n\n    // Set up polling if enabled\n    useEffect(() => {\n        // Initial fetch\n        fetchData();\n\n        // Set up polling if interval > 0\n        let intervalId: ReturnType<typeof setInterval> | undefined;\n\n        if (pollingInterval > 0) {\n            intervalId = setInterval(fetchData, pollingInterval);\n        }\n\n        // Cleanup\n        return () => {\n            if (intervalId) {\n                clearInterval(intervalId);\n            }\n        };\n    }, [fetchData, pollingInterval]);\n\n    const refresh = useCallback(async () => {\n        await fetchData();\n    }, [fetchData]);\n\n    return { data, loading, error, refresh };\n} "],"names":["flattenMultiPolygon","geojson","type","coordinates","flat","_a","geometry","__assign","simplifyPolygon","polygon","tolerance","turf","simplify","highQuality","mergePolygons","polygons","length","features","map","poly","feature","result","featureCollection","i","union","error","console","calculateArea","area","isPointInPolygon","point","pt","booleanPointInPolygon","optimizeForRendering","options","_b","simplifyTolerance","_c","flatten","LRUCache","capacity","this","cache","Map","prototype","get","key","has","value","delete","set","size","oldestKey","keys","next","undefined","clear","Array","from","memoize","fn","getKey","args","_i","arguments","JSON","stringify","apply","cachedResult","usePolygonOperations","defaultSimplifyTolerance","useMemoization","cacheSize","memoizedSimplify","useMemo","concat","memoizedFlatten","memoizedMerge","p","id","memoizedCalculateArea","memoizedIsPointInPolygon","join","useCallback","merge","contains","memoizedOptimize","data","properties","OptimizedPolygon","autoOptimize","_d","_e","children","optimizedData","dataWithId","React","PolygonMap","memo","renderPolygon","_f","_g","getPolygonId","className","style","operations","createElement","index","optimizedPolygon","url","_this","pollingInterval","useState","setData","loading","setLoading","_h","setError","useRef","Math","random","toString","substring","lastModified","Date","now","current","fetchData","__awaiter","fetch","response","sent","ok","Error","status","json","jsonData","processedData","err_1","String","useEffect","intervalId","setInterval","clearInterval","refresh"],"mappings":"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"}